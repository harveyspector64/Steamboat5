<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mississippi — Prototype E (Camera Lead • Ribbon Fix • Load/Unload Hotkeys) — Ellipse Clamp Patch</title>
  <style>
    html, body { height: 100%; margin: 0; background:#0a0f14; color:#e7f0f7; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #wrap { position: relative; height: 100%; }
    canvas { display:block; width:100%; height:100%; background: radial-gradient(1200px 800px at 50% 10%, #0d1a22 0%, #081118 60%, #060a0f 100%); }
    #hud { position:absolute; left:12px; top:12px; padding:10px 12px; background:rgba(8,12,16,0.65); border:1px solid rgba(255,255,255,0.08); border-radius:10px; backdrop-filter: blur(3px); user-select:none; }
    #hud h1 { font-size:14px; margin:0 0 6px 0; letter-spacing:.5px; opacity:.9; }
    #hud p { margin:4px 0; font-size:12px; opacity:.95; line-height:1.3; }
    #hud .kbd { display:inline-block; padding:1px 6px; border:1px solid rgba(255,255,255,0.25); border-radius:6px; font-size:11px; margin-right:4px; }
    #notice { position:absolute; right:12px; top:12px; padding:8px 10px; background:#00161f; border:1px solid rgba(255,255,255,0.08); border-radius:10px; font-size:12px; opacity:.9; }
    #job { position:absolute; right:12px; bottom:12px; padding:10px 12px; background:rgba(8,12,16,0.65); border:1px solid rgba(255,255,255,0.08); border-radius:10px; font-size:12px; min-width:260px; }
    .bar { width:180px; height:7px; background:rgba(255,255,255,0.08); border-radius:6px; overflow:hidden; display:inline-block; vertical-align:middle; margin-left:6px; }
    .fill { height:100%; background:linear-gradient(90deg, #a7f3d0, #10b981); }
    .fill.red { background:linear-gradient(90deg, #fecaca, #ef4444); }

    /* Port UI overlay */
    #portui{ position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); width:560px; max-width:95vw; background:rgba(6,12,18,0.94); border:1px solid rgba(255,255,255,0.12); border-radius:14px; padding:16px 16px 12px; box-shadow:0 20px 60px rgba(0,0,0,0.5); display:none; }
    #portui h2{ margin:0 0 10px; font-size:16px; letter-spacing:.4px; }
    #portui .row{ display:flex; gap:10px; }
    #portui .col{ flex:1; background:rgba(255,255,255,0.04); border:1px solid rgba(255,255,255,0.08); border-radius:12px; padding:10px; }
    #portui .section{ margin-bottom:8px; }
    #portui .btn{ display:inline-block; padding:6px 10px; border-radius:8px; border:1px solid rgba(255,255,255,0.18); background:rgba(255,255,255,0.06); color:#e7f0f7; font-size:12px; cursor:pointer; user-select:none; margin-right:6px; }
    #portui .btn:disabled{ opacity:.45; cursor:not-allowed; }

    /* Status toast */
    #status{ position:absolute; left:50%; transform:translateX(-50%); bottom:10px; background:rgba(0,0,0,0.6); border:1px solid rgba(255,255,255,0.15); color:#e7f0f7; padding:6px 10px; border-radius:10px; font-size:12px; display:none; }

    /* Thematic vignette */
    #vignette{ position:absolute; inset:0; pointer-events:none; background:radial-gradient(100% 85% at 50% 50%, rgba(0,0,0,0) 55%, rgba(0,0,0,0.3) 100%); mix-blend-mode:multiply; }

    /* Diagnostics badge */
    #diag { position:absolute; left:12px; bottom:50%; transform:translateY(50%); background:rgba(0,0,0,0.55); color:#e7f0f7; border:1px solid rgba(255,255,255,0.15); font:12px/1.3 system-ui, sans-serif; padding:6px 8px; border-radius:8px; display:none; }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game"></canvas>
    <div id="hud">
      <h1>Mississippi — Prototype D</h1>
      <p>W/S throttle · A/D steer · <span class="kbd">Space</span> stop · <span class="kbd">E</span> dock/undock (now auto-moor)</p>
      <p>Debug: <span class="kbd">F</span> flow · <span class="kbd">R</span> ribbons · <span class="kbd">G</span> grid · <span class="kbd">V</span> vortices · <span class="kbd">B</span> bars</p>
      <p id="stats"></p>
      <p>
        Hull <span class="bar"><span id="hullbar" class="fill red" style="width:100%"></span></span>
        &nbsp; Fuel <span class="bar"><span id="fuelbar" class="fill" style="width:100%"></span></span>
        &nbsp; Pressure <span class="bar" style="width:120px;"><span id="pressbar" class="fill" style="width:10%"></span></span>
        &nbsp; Cash $<span id="cash">0</span>
      </p>
      <p id="clock"></p>
    </div>
    <div id="notice">Dock assist, mooring lock, wakes & smoke, day/night, sepia chart vibe, and clearer docking prompts.</div>
    <div id="job">
      <div id="jobline">No contract.</div>
      <div id="jobhint" style="opacity:.9; margin-top:6px;">Line up on the white marker. When the prompt appears, press <b>E</b> to auto-moor.</div>
    </div>

    <!-- Port overlay -->
    <div id="portui">
      <h2>Harbormaster — <span id="portname">Town</span></h2>
      <div class="row">
        <div class="col" style="flex:1.2">
          <div class="section"><b>Vessel Services</b></div>
          <div class="section">Hull: <span id="dock_hull">100%</span> &nbsp; Fuel: <span id="dock_fuel">100%</span></div>
          <div class="section">
            <button class="btn" id="btn_repair">Repair ($<span id="repair_cost">0</span>)</button>
            <button class="btn" id="btn_refuel">Refuel to Full ($<span id="refuel_cost">0</span>)</button>
          </div>
          <div class="section" id="cargo_section" style="display:none">
            <button class="btn" id="btn_load">Load cargo & depart</button>
            <button class="btn" id="btn_unload">Unload cargo</button>
          </div>
          <div class="section"><button class="btn" id="btn_depart">Depart (Undock)</button></div>
        </div>
        <div class="col">
          <div class="section"><b>Contracts</b></div>
          <div id="jobs_list" class="section" style="max-height:180px; overflow:auto"></div>
        </div>
      </div>
    </div>
    <div id="status"></div>
    <div id="vignette"></div>
    <div id="diag"></div>
  </div>

  <script>
  (()=>{
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const noticeEl = document.getElementById('notice'); // used early in docking helpers

    // --- Geometry guards for ellipse (fix IndexSizeError) ---
    const EPS = 0.001;
    function good(n){ return Number.isFinite(n) && n > EPS; }
    function safeEllipsePath(x,y,rx,ry,rot=0,start=0,end=Math.PI*2){
      rx = Math.abs(rx); ry = Math.abs(ry);
      if(!good(rx) || !good(ry)) return false;
      ctx.ellipse(x,y,rx,ry,rot,start,end);
      return true;
    }

    // DPI handling
    function resize(){
      const dpr = Math.min(2, window.devicePixelRatio || 1);
      canvas.width = Math.floor(canvas.clientWidth * dpr);
      canvas.height = Math.floor(canvas.clientHeight * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
    }
    window.addEventListener('resize', resize);
    resize();

    // ===== WORLD CONSTANTS =====
    const RIVER_WIDTH = 1200;           // world units (CSS px)
    const BASE_FLOW   = 86;             // px/s downward baseline
    const TURN_BASE   = 1.6;            // rad/s at decent way-through-water
    const MAX_THRUST  = 170;            // px/s^2 (engine force)
    const HULL_DRAG   = 0.9;            // pull of boat toward local water velocity
    const EDGE_MARGIN = 24;             // bank collision padding

    // Field shaping
    const LATERAL_CENTERING = 3.0;      // keeps flow coherent toward center
    const VORTEX_COUNT = 22;
    const VORTEX_STRENGTH = 22000;      // circulation scale
    const VORTEX_RADIUS = 220;          // influence radius

    // Shallows / sandbars
    const BARS = [];
    const SHOW = { help:true, vectors:false, ribbons:true, grid:false, vorts:false, bars:true };

    // Economy constants
    const FUEL_PRICE = 0.8;   // $ per unit
    const REPAIR_PRICE = 150; // $ for full repair (scaled by damage)

    // Camera (follows player)
    const camera = { x: RIVER_WIDTH/2, y: -200 };

    // Date/time sim
    const clockEl = document.getElementById('clock');
    const simClock = { year:1857, month:5, day:3, minutes:8*60+12, rate: 6 }; // rate: minutes per real second

    function advanceClock(dt){
      simClock.minutes += simClock.rate*dt;
      while(simClock.minutes>=24*60){ simClock.minutes -= 24*60; simClock.day++; }
    }
    function formatClock(){
      const h = Math.floor(simClock.minutes/60); const m = Math.floor(simClock.minutes%60);
      const mm = (m<10?'0':'')+m; const hh = (h%12||12); const am = h<12? 'AM' : 'PM';
      return `May ${simClock.day}, ${simClock.year} — ${hh}:${mm} ${am}`;
    }

    function rand(min,max){ return min + Math.random()*(max-min); }

    // ===== VORTICES (eddies drifting downriver)
    const vortices = [];
    function spawnVortex(aroundY){
      vortices.push({
        x: rand(140, RIVER_WIDTH-140), y: aroundY + rand(-1200, 1200),
        gamma: (Math.random()<0.5?-1:1) * rand(0.6,1.3) * VORTEX_STRENGTH,
        r: rand(0.7,1.3) * VORTEX_RADIUS,
      });
    }
    for(let i=0;i<VORTEX_COUNT;i++) spawnVortex(camera.y + rand(-2400, 2400));

    function updateVortices(dt){
      for(const v of vortices){
        v.y += (BASE_FLOW*0.85) * dt; // drift downriver
        v.x += Math.sin((v.y+v.x)*0.0009) * 14 * dt; // tiny meander
        if(v.y > camera.y + 3000){ // recycle
          v.x = rand(140, RIVER_WIDTH-140);
          v.y = camera.y - 2800 - rand(0,300);
          v.gamma = (Math.random()<0.5?-1:1) * rand(0.6,1.3) * VORTEX_STRENGTH;
          v.r = rand(0.7,1.3) * VORTEX_RADIUS;
        }
      }
    }

    // ===== SPEED PROFILE & CENTER PULL
    function centerSpeedFactor(x){
      const cx = RIVER_WIDTH/2; const nx = (x - cx) / (RIVER_WIDTH/2);
      const parabolic = 1 - Math.min(1, nx*nx);
      return 0.60 + 0.50*parabolic; // 0.6 at edges -> 1.1 at center
    }
    function centerPull(x){ const cx = RIVER_WIDTH/2; return (cx - x) * 0.0025 * LATERAL_CENTERING; }

    // ===== SHALLOWS (elliptical bars)
    function seedBars(){
      BARS.length = 0;
      const bands = [ -400, 600, 1700, 2600, 3600, 4700 ];
      for(const y of bands){
        const onLeft = Math.random()<0.5;
        const x = onLeft ? rand(260, 520) : rand(RIVER_WIDTH-520, RIVER_WIDTH-260);
        BARS.push({ x, y, rx: rand(120,220), ry: rand(220,360), slow: rand(0.5,0.8) });
      }
    }
    seedBars();

    function shallowFactor(x,y){
      let f = 1; // 1 = deep; <1 = shallow
      for(const b of BARS){
        const dx = (x - b.x)/b.rx; const dy = (y - b.y)/b.ry; const d2 = dx*dx + dy*dy;
        if(d2 < 1){
          const t = 1 - d2; // inside ellipse
          f *= (b.slow + (1-b.slow)*(1 - t*t)); // more slowdown near center
        }
      }
      const margin = Math.min(x, RIVER_WIDTH-x); // banks are shallower too
      const bankShallow = Math.max(0, 1 - Math.pow(margin/200, 2));
      f *= (1 - 0.35*bankShallow);
      return Math.max(0.35, Math.min(1, f));
    }

    // ===== WATER VELOCITY FIELD at (x,y)
    function waterVelocity(x, y){
      let vx = 0;
      let vy = BASE_FLOW * centerSpeedFactor(x) * (1 + 0.10 * Math.sin(y*0.0012));
      const shall = shallowFactor(x,y);
      vy *= shall; // slower over bars/banks
      vx += Math.sin(y*0.00075) * 16 * shall; // sinuous sweep reduced over shallows
      vx += centerPull(x) * (0.8 + 0.2*shall);

      for(const v of vortices){ // vortices
        const dx = x - v.x; const dy = y - v.y; const r2 = dx*dx + dy*dy + 1; const r = Math.sqrt(r2);
        if(r < v.r*2.5){ const fall = Math.exp(-(r*r)/(v.r*v.r*0.9)); const mag = (v.gamma / (r2 + 400)) * fall; vx += (-dy) * mag; vy += ( dx) * mag; }
      }

      // slight push away from sandbar crests (flow splits)
      for(const b of BARS){ const dx = x - b.x; const dy = y - b.y; const r = Math.hypot(dx/b.rx, dy/b.ry); if(r<1.2){ const push = (1.2 - r) * 14; vx += (dx>0?1:-1) * push; vy += (dy>0?1:-1) * push * 0.15; } }
      return {x: vx, y: vy};
    }

    // ===== PORTS (upstream -> downstream)
    const ports = [
      { name:'Cairo',       x: 120,  y:-800 },
      { name:'Memphis',     x:1080,  y: 400 },
      { name:'Helena',      x: 160,  y:1400 },
      { name:'Vicksburg',   x:1040,  y:2500 },
      { name:'Natchez',     x: 160,  y:3600 },
      { name:'New Orleans', x:1000,  y:4800 },
    ].map(p=>({ ...p, dockX: p.x < RIVER_WIDTH/2 ? p.x + 70 : p.x - 70, dockY: p.y + 40 }));

    // ===== PLAYER BOAT
    const boat = {
      x: RIVER_WIDTH/2, y: -500, vx: 0, vy: BASE_FLOW,
      angle: Math.PI/2, throttle: 0, targetThrottle: 0,
      length: 110, width: 24,
      hull: 1.0, cash: 80,
      fuel: 100, maxFuel: 100,
      pressure: 8, // 0..100
      dockedAt: null, // index of port when docked (hard lock)
    };

    // Mooring state (for hard lock & undock impulse)
    const moor = { active:false, x:0, y:0, angle:0 };

    // ===== AI TRAFFIC (one steamer with simple port stops)
    const ai = { name: 'Delta Queen', x: RIVER_WIDTH*0.65, y: -900, vx: 0, vy: BASE_FLOW, angle: Math.PI/2, throttle: 0.6, state: 'RUN', targetPort: 1, dwell: 0 };

    // ===== JOB SYSTEM
    const portJobs = new Map();
    const job = { state:'NONE', origin:null, dest:null, timeLimit:0, timer:0, payout:0 };

    function jobsForPort(pi){
      if(portJobs.has(pi)) return portJobs.get(pi);
      const here = ports[pi]; const options = [];
      const dests = ports.filter((p,idx)=> idx!==pi && p.y>here.y);
      const picks = dests.length? dests.slice(0,4) : ports.filter((_,idx)=>idx!==pi).slice(0,4);
      for(let i=0;i<Math.min(3, picks.length); i++){
        const d = picks[i]; const distY = Math.abs(d.y - here.y);
        const baseTime = Math.max(70, distY / 180); // seconds heuristic
        const time = Math.round(baseTime * (1.1 + Math.random()*0.6));
        const pay = Math.round(60 + distY * (0.08 + Math.random()*0.05));
        options.push({ origin:pi, dest: ports.indexOf(d), timeLimit: time, payout: pay });
      }
      portJobs.set(pi, options); return options;
    }

    // ===== INPUT
    const keys = new Set();
    window.addEventListener('keydown', (e)=>{
      const k = e.key.toLowerCase(); keys.add(k);
      if(['w','a','s','d','arrowup','arrowdown','arrowleft','arrowright',' ','e','f','r','g','v','b','h','l','u'].includes(k)) e.preventDefault();
      if(k===' ') { boat.targetThrottle = 0; boat.throttle = 0; }
      if(k==='h') SHOW.help = !SHOW.help;
      if(k==='f') SHOW.vectors = !SHOW.vectors;
      if(k==='r') SHOW.ribbons = !SHOW.ribbons;
      if(k==='g') SHOW.grid = !SHOW.grid;
      if(k==='v') SHOW.vorts = !SHOW.vorts;
      if(k==='b') SHOW.bars = !SHOW.bars;
      if(k==='e') tryDockUndock();
      if(k==='l') tryLoad();
      if(k==='u') tryUnload();
    });
    window.addEventListener('keyup', (e)=>{ keys.delete(e.key.toLowerCase()); });

    function tryDockUndock(){
      const d = nearestDockTo(boat.x, boat.y);
      if(!d){ flashStatus('No dock nearby.'); return; }
      // Already docked? Undock with a gentle shove.
      if(boat.dockedAt!==null){ undock(); return; }
      // Assist: within generous radius, moor regardless of speed. We'll snap & lock.
      const distTo = dist(boat.x,boat.y,d.x,d.y);
      if(distTo < 140){ startMoor(d.index); openPortUI(); } else { flashStatus('Closer to the white marker to dock.'); }
    }

    function startMoor(portIndex){
      const p = ports[portIndex];
      const wv = waterVelocity(p.dockX, p.dockY);
      boat.dockedAt = portIndex; // hard lock state
      boat.targetThrottle = 0; boat.throttle = 0;
      boat.x = p.dockX; boat.y = p.dockY; boat.vx = wv.x; boat.vy = wv.y;
      moor.active = true; moor.x = p.dockX; moor.y = p.dockY; moor.angle = Math.PI/2; // aligned downriver
      flashStatus('Lines fastened.');
      if(job.state==='PICKUP' && job.origin===boat.dockedAt) noticeEl.textContent = 'Docked — Press L to Load cargo, or use the Harbormaster. Press E to cast off.';
      else if(job.state==='IN_TRANSIT' && job.dest===boat.dockedAt) noticeEl.textContent = 'Docked — Press U to Unload cargo, or use the Harbormaster. Press E to cast off.';
      else noticeEl.textContent = 'Docked — Press E to open Harbormaster, L to load (if origin), U to unload (if destination).';
    }

    function undock(){
      const p = ports[boat.dockedAt];
      boat.dockedAt = null; moor.active = false; closePortUI();
      const away = p.x < RIVER_WIDTH/2 ? 1 : -1; // push toward center
      boat.vx += 28 * away; boat.vy += 8; // a little downriver drift
      flashStatus('Cast off.');
      noticeEl.textContent = 'Dock assist, mooring lock, wakes & smoke, day/night, sepia chart vibe, and clearer docking prompts.';
    }

    // ===== RIBBONS (visualized strands)
    const RIBBON_COUNT = 42, RIB_POINTS = 60, RIB_SPACING_Y = 60; const RIBBONS = [];
    function initRibbons(){
      RIBBONS.length = 0;
      for(let i=0;i<RIBBON_COUNT;i++){
        const tx = (i+0.5) * (RIVER_WIDTH / RIBBON_COUNT);
        const pts = [];
        for(let p=0;p<RIB_POINTS;p++){
          const py = camera.y - 2000 + p*RIB_SPACING_Y + Math.random()*8;
          pts.push({ x: tx + (Math.random()-0.5)*8, y: py });
        }
        RIBBONS.push({ pts });
      }
    }
    initRibbons();

    function updateRibbons(dt){
      const botY = camera.y + 2200;
      const topY = camera.y - 2200;
      for(const rib of RIBBONS){
        const pts = rib.pts;
        for(const pt of pts){
          const v = waterVelocity(pt.x, pt.y);
          pt.x += v.x * dt; pt.y += v.y * dt;
          if(pt.x < EDGE_MARGIN) pt.x = EDGE_MARGIN; if(pt.x > RIVER_WIDTH-EDGE_MARGIN) pt.x = RIVER_WIDTH-EDGE_MARGIN;
        }
        // recycle both below and above to keep coverage when moving up or down river
        for(const pt of pts){
          if(pt.y > botY){ pt.y -= (RIB_POINTS-2)*RIB_SPACING_Y; pt.x += (Math.random()-0.5)*10; }
          if(pt.y < topY){ pt.y += (RIB_POINTS-2)*RIB_SPACING_Y; pt.x += (Math.random()-0.5)*10; }
        }
      }
    }

    // ===== PARTICLES (wake & smoke)
    const wake = []; const smoke = [];
    function spawnWake(x,y,dir){ wake.push({x,y,life:1,dir}); }
    function spawnSmoke(x,y){ smoke.push({x,y,life:1}); }

    function updateParticles(dt){
      // wake from both boats
      const wb = toScreen(boat.x, boat.y + 36);
      if(Math.random()<0.6) spawnWake(wb.x + (Math.random()-0.5)*8, wb.y + 6, boat.angle);
      const wa = toScreen(ai.x, ai.y + 36);
      if(Math.random()<0.5) spawnWake(wa.x + (Math.random()-0.5)*8, wa.y + 6, ai.angle);
      // smoke from pilot house area
      const sb = toScreen(boat.x, boat.y - 40);
      if(Math.random()<0.35) spawnSmoke(sb.x + (Math.random()-0.5)*6, sb.y - 8);

      for(const p of wake){ p.life -= dt*0.6; }
      for(const s of smoke){ s.life -= dt*0.25; }
      while(wake.length && wake[0].life<=0) wake.shift();
      while(smoke.length && smoke[0].life<=0) smoke.shift();
    }

    function drawParticles(){
      // wake
      ctx.save();
      for(const p of wake){
        const rx = 10*(1 - p.life), ry = 4*(1 - p.life);
        const alpha = Math.max(0, p.life)*0.35;
        if(!good(rx) || !good(ry)){ continue; }
        ctx.globalAlpha = alpha;
        ctx.beginPath();
        if(safeEllipsePath(p.x, p.y, rx, ry)) { ctx.fillStyle = '#e6f7ff'; ctx.fill(); }
      }
      ctx.restore();
      // smoke
      ctx.save();
      for(const s of smoke){
        const rise = (1 - s.life) * 25;
        const rx = 12*(1 - s.life), ry = 8*(1 - s.life); // fixed: was '8*(1-s-life)'
        const alpha = Math.max(0, s.life)*0.25;
        if(!good(rx) || !good(ry)){ continue; }
        ctx.globalAlpha = alpha;
        ctx.beginPath();
        if(safeEllipsePath(s.x, s.y - rise, rx, ry)) { ctx.fillStyle = '#c6c3bd'; ctx.fill(); }
      }
      ctx.restore();
      ctx.globalAlpha = 1;
    }

    // ===== PHYSICS HELPERS
    function dist(x1,y1,x2,y2){ return Math.hypot(x2-x1,y2-y1); }

    // ===== BOAT UPDATE
    function updateBoat(dt){
      // throttle control
      const forward = keys.has('w') || keys.has('arrowup');
      const back = keys.has('s') || keys.has('arrowdown');
      if(forward && !back) boat.targetThrottle = Math.min(1, boat.targetThrottle + 0.8*dt);
      else if(back && !forward) boat.targetThrottle = Math.max(-0.5, boat.targetThrottle - 0.9*dt);
      else boat.targetThrottle *= (1 - 0.8*dt);

      // while docked, hard lock: ignore inputs & stick position
      if(boat.dockedAt!==null){
        const p = ports[boat.dockedAt];
        const wv = waterVelocity(p.dockX, p.dockY);
        boat.throttle = 0; boat.vx = wv.x; boat.vy = wv.y; boat.x = p.dockX; boat.y = p.dockY; boat.angle = moor.angle;
      } else {
        // smooth throttle
        boat.throttle += (boat.targetThrottle - boat.throttle) * Math.min(1, 6*dt);

        // steering
        const left = keys.has('a') || keys.has('arrowleft');
        const right = keys.has('d') || keys.has('arrowright');
        const wv = waterVelocity(boat.x, boat.y);
        const rvx = boat.vx - wv.x; const rvy = boat.vy - wv.y; const relSpeed = Math.hypot(rvx,rvy);
        let steer = 0; if(left && !right) steer=-1; else if(right && !left) steer=1;
        const turnRate = TURN_BASE * Math.min(1.0, relSpeed/120);
        boat.angle += steer * turnRate * dt;

        // engine / boiler model
        const thrust = MAX_THRUST * boat.throttle * (0.85 + 0.15*(1 - boat.pressure/100));
        const fuelUse = Math.max(0, Math.abs(boat.throttle)) * 0.20 * (1 + 0.3*(boat.pressure/100));
        boat.fuel = Math.max(0, boat.fuel - fuelUse * dt);
        const effectiveThrust = boat.fuel>0 ? thrust : 0;

        // pressure dynamics
        const targetPress = Math.max(6, Math.abs(boat.throttle)*100*0.75);
        boat.pressure += (targetPress - boat.pressure) * Math.min(1, 0.8*dt);
        if(boat.pressure>98 && Math.random()<0.002){ damage(0.01); flashStatus('Boiler strain! Ease throttle.'); }

        // apply thrust along heading
        boat.vx += Math.cos(boat.angle) * effectiveThrust * dt;
        boat.vy += Math.sin(boat.angle) * effectiveThrust * dt;

        // hydrodynamic drag toward local water
        boat.vx += (wv.x - boat.vx) * (1 - Math.exp(-HULL_DRAG*dt));
        boat.vy += (wv.y - boat.vy) * (1 - Math.exp(-HULL_DRAG*dt));

        // integrate position
        boat.x += boat.vx * dt; boat.y += boat.vy * dt;

        // banks bounce
        if(boat.x < EDGE_MARGIN){ boat.x = EDGE_MARGIN; boat.vx *= -0.2; damage(0.06*dt); }
        if(boat.x > RIVER_WIDTH-EDGE_MARGIN){ boat.x = RIVER_WIDTH-EDGE_MARGIN; boat.vx *= -0.2; damage(0.06*dt); }

        // shallow damage + grounding friction when speeding
        const shall = shallowFactor(boat.x, boat.y);
        if(shall < 0.8){
          const wv2 = waterVelocity(boat.x, boat.y);
          const tw = Math.hypot(boat.vx-wv2.x, boat.vy-wv2.y);
          if(tw > 60) damage(((0.8 - shall) * (tw-60)) * 0.0006 * dt);
          if(shall<0.7){ boat.vx *= (0.995 + shall*0.003); boat.vy *= (0.995 + shall*0.003); }
        }
      }

      // simple collision with AI
      const dx = ai.x - boat.x, dy = ai.y - boat.y; const d2 = dx*dx+dy*dy; const minD = 90;
      if(d2 < minD*minD){
        const d = Math.max(10, Math.sqrt(d2)); const ux = dx/d, uy = dy/d; const push = (minD - d) * 12 * dt;
        boat.vx -= ux*push; boat.vy -= uy*push; ai.vx += ux*push; ai.vy += uy*push; damage(0.02*dt);
      }

      // UI
      const wv = waterVelocity(boat.x, boat.y);
      const gs = Math.hypot(boat.vx, boat.vy);
      const tw = Math.hypot(boat.vx - wv.x, boat.vy - wv.y);
      const ws = Math.hypot(wv.x, wv.y);
      document.getElementById('stats').textContent = `SOG ${gs.toFixed(1)}  |  STW ${tw.toFixed(1)}  |  River ${ws.toFixed(1)}`;
      document.getElementById('hullbar').style.width = `${Math.max(0, boat.hull*100)}%`;
      document.getElementById('fuelbar').style.width = `${(boat.fuel/boat.maxFuel*100).toFixed(0)}%`;
      document.getElementById('pressbar').style.width = `${Math.min(100, boat.pressure).toFixed(0)}%`;
      document.getElementById('cash').textContent = boat.cash.toFixed(0);
      clockEl.textContent = formatClock();
    }

    function damage(amount){ boat.hull = Math.max(0, boat.hull - amount); }

    // ===== AI UPDATE
    function updateAI(dt){
      if(ai.state==='RUN'){
        if(ai.targetPort===null || Math.random()<0.003){
          const candidates = ports.filter((p)=> p.y > camera.y - 400 && p.y < camera.y + 1800);
          const pick = candidates.length? candidates[Math.floor(Math.random()*candidates.length)] : ports[Math.floor(Math.random()*ports.length)];
          ai.targetPort = ports.indexOf(pick);
        }
      }
      const target = ports[ai.targetPort];
      const wv = waterVelocity(ai.x, ai.y);
      const rvx = ai.vx - wv.x; const rvy = ai.vy - wv.y; const relSpeed = Math.hypot(rvx,rvy);
      if(ai.state==='RUN' || ai.state==='APPROACH'){
        const dock = {x: target.dockX, y: target.dockY};
        const angTo = Math.atan2(dock.y - ai.y, dock.x - ai.x);
        let diff = ((angTo - ai.angle + Math.PI) % (Math.PI*2)) - Math.PI;
        ai.angle += Math.max(-TURN_BASE*dt, Math.min(TURN_BASE*dt, diff*0.7));
        let t = 0.75 - 0.15*Math.abs(diff); // throttle target
        const dd = Math.hypot(dock.x-ai.x, dock.y-ai.y);
        if(dd < 260) { ai.state='APPROACH'; t = Math.min(t, 0.25); }
        if(dd < 90 && relSpeed < 28){ ai.state='DOCKED'; ai.dwell = 4 + Math.random()*4; ai.vx = wv.x; ai.vy = wv.y; t = 0; }
        ai.throttle += (t - ai.throttle) * 0.6*dt;
      }
      if(ai.state==='DOCKED'){
        ai.dwell -= dt;
        if(ai.dwell<=0){
          const candidates = ports.filter(p=> p!==target && p.y > camera.y - 600 && p.y < camera.y + 2000);
          const pick = candidates.length? candidates[Math.floor(Math.random()*candidates.length)] : ports[(ai.targetPort+1)%ports.length];
          ai.targetPort = ports.indexOf(pick); ai.state='RUN'; ai.throttle = 0.6;
        }
      }
      const thrust = MAX_THRUST * ai.throttle * 0.85;
      ai.vx += Math.cos(ai.angle) * thrust * dt; ai.vy += Math.sin(ai.angle) * thrust * dt;
      ai.vx += (wv.x - ai.vx) * (1 - Math.exp(-HULL_DRAG*dt)); ai.vy += (wv.y - ai.vy) * (1 - Math.exp(-HULL_DRAG*dt));
      ai.x += ai.vx * dt; ai.y += ai.vy * dt;
      if(ai.x < EDGE_MARGIN){ ai.x = EDGE_MARGIN; ai.vx *= -0.2; }
      if(ai.x > RIVER_WIDTH-EDGE_MARGIN){ ai.x = RIVER_WIDTH-EDGE_MARGIN; ai.vx *= -0.2; }
    }

    // ===== CAMERA follows player, with lead ahead/astern
    function updateCamera(dt){
      // Keep boat offset toward direction of travel (so you can see ahead)
      const h = canvas.clientHeight;
      const wv = waterVelocity(boat.x, boat.y);
      const relY = boat.vy - wv.y; // downstream > 0, upstream < 0
      const leadFrac = relY>8 ? 0.18 : (relY<-8 ? -0.18 : 0); // bias when actually making way
      const desiredY = boat.y + h*leadFrac;
      camera.y += (desiredY - camera.y) * Math.min(1, 2.5*dt);
    }

    // ===== DRAW HELPERS
    function toScreen(x,y){ return { x: (x - camera.x) + canvas.clientWidth/2, y: (y - camera.y) + canvas.clientHeight/2 }; }

    function drawRiverBackground(){
      // water band gradient across width
      const gx = toScreen(0,0).x; const gx2 = toScreen(RIVER_WIDTH,0).x;
      const grd = ctx.createLinearGradient(gx,0,gx2,0);
      grd.addColorStop(0, 'rgba(56,64,68,0.08)');
      grd.addColorStop(0.1, 'rgba(42,86,98,0.62)');
      grd.addColorStop(0.9, 'rgba(42,86,98,0.62)');
      grd.addColorStop(1, 'rgba(56,64,68,0.08)');
      ctx.fillStyle = grd; ctx.fillRect(gx,0, gx2-gx, canvas.clientHeight);
      // shoreline silhouettes
      ctx.save();
      ctx.fillStyle = 'rgba(12,18,24,0.85)';
      const leftX = toScreen(0,0).x; const rightX = toScreen(RIVER_WIDTH,0).x;
      ctx.fillRect(0,0,leftX,canvas.clientHeight);
      ctx.fillRect(rightX,0,canvas.clientWidth-rightX,canvas.clientHeight);
      // subtle bank foam
      ctx.globalAlpha = 0.18; ctx.fillStyle = '#d8f2ff';
      for(let y=camera.y-1000; y<camera.y+1500; y+=220){ const s1 = toScreen(10,y).y; const s2 = toScreen(RIVER_WIDTH-10,y+12).y; ctx.fillRect(leftX, s1, 6, 2); ctx.fillRect(rightX-6, s2, 6, 2); }
      ctx.restore();
    }

    function drawBars(){
      if(!SHOW.bars) return;
      ctx.save();
      for(const b of BARS){
        const s = toScreen(b.x, b.y);
        // fill
        ctx.beginPath();
        if(!safeEllipsePath(s.x, s.y, b.rx, b.ry)) { continue; }
        ctx.fillStyle = 'rgba(240, 214, 170, 0.18)'; ctx.fill();
        // hatch lines for a chart vibe (clip safely)
        ctx.save(); ctx.beginPath(); if(safeEllipsePath(s.x, s.y, b.rx, b.ry)){ ctx.clip();
          ctx.strokeStyle = 'rgba(240,214,170,0.25)'; ctx.lineWidth = 1;
          for(let yy=-b.ry; yy<=b.ry; yy+=10){ ctx.beginPath(); ctx.moveTo(s.x - b.rx, s.y + yy + (yy%20?0:3)); ctx.lineTo(s.x + b.rx, s.y + yy - (yy%20?0:3)); ctx.stroke(); }
        } ctx.restore();
        // outline
        ctx.beginPath(); if(safeEllipsePath(s.x, s.y, b.rx, b.ry)){ ctx.strokeStyle = 'rgba(240,214,170,0.28)'; ctx.lineWidth = 1; ctx.stroke(); }
      }
      ctx.restore();
    }

    function drawRibbons(){ if(!SHOW.ribbons) return; ctx.save(); ctx.lineWidth = 2.0; ctx.globalAlpha = 0.62; for(const rib of RIBBONS){ const pts = rib.pts; ctx.beginPath(); for(let i=0;i<pts.length;i++){ const s = toScreen(pts[i].x, pts[i].y); if(i===0) ctx.moveTo(s.x,s.y); else ctx.lineTo(s.x,s.y); } ctx.strokeStyle = 'rgba(190, 230, 255, 0.22)'; ctx.stroke(); } ctx.restore(); }

    function drawFlowVectors(){ if(!SHOW.vectors) return; ctx.save(); const step = 90; for(let sx=0; sx<canvas.clientWidth; sx+=step){ for(let sy=0; sy<canvas.clientHeight; sy+=step){ const worldX = camera.x - canvas.clientWidth/2 + sx; const worldY = camera.y - canvas.clientHeight/2 + sy; if(worldX<0||worldX>RIVER_WIDTH) continue; const v = waterVelocity(worldX, worldY); const len = Math.hypot(v.x, v.y); const n = len>0 ? {x:v.x/len, y:v.y/len} : {x:0,y:1}; const L = Math.min(28, 10 + len*0.05); ctx.beginPath(); ctx.moveTo(sx, sy); ctx.lineTo(sx + n.x*L, sy + n.y*L); ctx.moveTo(sx + n.x*L, sy + n.y*L); ctx.lineTo(sx + n.x*L - n.y*6, sy + n.y*L + n.x*6); ctx.moveTo(sx + n.x*L, sy + n.y*L); ctx.lineTo(sx + n.x*L + n.y*6, sy + n.y*L - n.x*6); ctx.strokeStyle = 'rgba(255,255,255,0.18)'; ctx.lineWidth = 1; ctx.stroke(); } } ctx.restore(); }

    function drawGrid(){ if(!SHOW.grid) return; ctx.save(); ctx.strokeStyle = 'rgba(255,255,255,0.05)'; ctx.lineWidth = 1; const step = 200; const startX = Math.floor((camera.x - canvas.clientWidth/2)/step)*step; const endX = Math.ceil((camera.x + canvas.clientWidth/2)/step)*step; const startY = Math.floor((camera.y - canvas.clientHeight/2)/step)*step; const endY = Math.ceil((camera.y + canvas.clientHeight/2)/step)*step; for(let x=startX; x<=endX; x+=step){ const a = toScreen(x, startY); const b = toScreen(x, endY); ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x,b.y); ctx.stroke(); } for(let y=startY; y<=endY; y+=step){ const a = toScreen(startX, y); const b = toScreen(endX, y); ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x,b.y); ctx.stroke(); } ctx.restore(); }

    function drawPort(p){
      const edgeX = p.x < RIVER_WIDTH/2 ? toScreen(0,p.y).x : toScreen(RIVER_WIDTH,p.y).x;
      const s = toScreen(p.dockX, p.dockY);
      // pier
      ctx.save(); ctx.strokeStyle = 'rgba(245,245,245,0.35)'; ctx.lineWidth = 8; ctx.beginPath(); ctx.moveTo(edgeX, s.y); ctx.lineTo(s.x, s.y); ctx.stroke();
      // dock marker (glow when in range)
      const near = dist(boat.x, boat.y, p.dockX, p.dockY) < 160;
      ctx.beginPath(); ctx.arc(s.x, s.y, 8, 0, Math.PI*2); ctx.fillStyle = near? '#b3f0ff' : '#ffffff'; ctx.fill();
      if(near){ ctx.globalAlpha = 0.18; ctx.beginPath(); ctx.arc(s.x, s.y, 18, 0, Math.PI*2); ctx.fillStyle = '#b3f0ff'; ctx.fill(); ctx.globalAlpha = 1; }
      // label
      ctx.font = '12px system-ui, sans-serif'; ctx.fillStyle = '#e7f0f7'; ctx.fillText(p.name, s.x + (p.x<RIVER_WIDTH/2?10:-60), s.y - 10);
      // in-range prompt sash
      if(near){ const msg = 'Press E to Dock'; ctx.font = '11px system-ui, sans-serif'; const w = ctx.measureText(msg).width + 12; ctx.fillStyle = 'rgba(0,0,0,0.55)'; ctx.fillRect(s.x - w/2, s.y + 16, w, 16); ctx.fillStyle = '#dff8ff'; ctx.fillText(msg, s.x - w/2 + 6, s.y + 28); }
      ctx.restore();
    }

    function drawPorts(){ for(const p of ports){ drawPort(p); } }

    function drawBoat(b, isPlayer){
      const s = toScreen(b.x, b.y);
      ctx.save(); ctx.translate(s.x, s.y); ctx.rotate(b.angle + Math.PI/2);
      const L = b.length||110, W = b.width||24;
      // hull
      ctx.beginPath(); ctx.moveTo(0, -L*0.5); ctx.quadraticCurveTo(W*0.5, -L*0.35, W*0.5, 0); ctx.lineTo(W*0.5, L*0.35); ctx.quadraticCurveTo(0, L*0.52, -W*0.5, L*0.35); ctx.lineTo(-W*0.5, 0); ctx.quadraticCurveTo(-W*0.5, -L*0.35, 0, -L*0.5); ctx.closePath();
      ctx.fillStyle = isPlayer? '#c7cbd1' : '#d9d1c7'; ctx.globalAlpha = 0.95; ctx.fill(); ctx.globalAlpha = 1; ctx.strokeStyle = 'rgba(0,0,0,0.35)'; ctx.lineWidth = 2; ctx.stroke();
      // pilot house
      ctx.beginPath(); ctx.rect(-W*0.25, -L*0.18, W*0.5, L*0.18); ctx.fillStyle = '#e5e7eb'; ctx.fill();
      // paddle wheel hint
      ctx.beginPath(); ctx.arc(0, L*0.36, W*0.6, Math.PI*0.12, Math.PI*0.88); ctx.strokeStyle = 'rgba(0,0,0,0.45)'; ctx.stroke();
      ctx.restore();
      // AI name label
      if(!isPlayer){ ctx.save(); ctx.font='11px system-ui,sans-serif'; ctx.fillStyle='rgba(255,255,255,0.75)'; ctx.fillText(ai.name, s.x-24, s.y-60); ctx.restore(); }
    }

    function drawJobHUD(){
      const el = document.getElementById('jobline');
      const hint = document.getElementById('jobhint');
      if(job.state==='NONE'){ el.textContent = 'No contract.'; hint.style.display='block'; return; }
      const o = ports[job.origin]; const d = ports[job.dest];
      if(job.state==='PICKUP'){
        el.textContent = `Contract: ${o.name} → ${d.name}  ·  Payout $${job.payout}  ·  Time ${job.timeLimit}s`;
        hint.innerHTML = `Dock at <b>${o.name}</b> and press <b>L</b> to load.`; hint.style.display='block';
      } else if(job.state==='IN_TRANSIT'){
        const left = Math.max(0, job.timeLimit - job.timer);
        el.textContent = `Deliver: ${o.name} → ${d.name}  ·  Time left ${left.toFixed(1)}s`;
        hint.innerHTML = `Dock at <b>${d.name}</b> and press <b>U</b> to unload.`; hint.style.display='block';
      } else if(job.state==='DELIVERED'){
        el.textContent = `Delivered to ${d.name}! Earned $${job.payout}.`;
        hint.innerHTML = `Pick up another contract at any dock.`; hint.style.display='block';
      } else if(job.state==='LATE'){
        el.textContent = `Delivered late to ${d.name}. Earned $${Math.floor(job.payout*0.45)}.`;
        hint.innerHTML = `Pick up another contract at any dock.`; hint.style.display='block';
      }
    }

    function drawMinimap(){
      const w = 180, h = 120; const x = 12, y = canvas.clientHeight - h - 12; ctx.save();
      ctx.globalAlpha = 0.95; ctx.fillStyle='rgba(0,0,0,0.35)'; ctx.fillRect(x-2,y-2,w+4,h+4); ctx.fillStyle='rgba(10,20,26,0.7)'; ctx.fillRect(x,y,w,h);
      const spanY = 2200; const top = camera.y - spanY*0.2; const bot = camera.y + spanY*0.8;
      for(const p of ports){ const px = x + (p.dockX / RIVER_WIDTH) * w; const py = y + ((p.dockY - top) / (bot - top)) * h; if(py>y && py<y+h){ ctx.fillStyle='#c9e3f8'; ctx.fillRect(px-2,py-2,4,4); } }
      const pbx = x + (boat.x / RIVER_WIDTH) * w; const pby = y + ((boat.y - top)/(bot-top))*h; ctx.fillStyle='#a7f3d0'; ctx.fillRect(pbx-2,pby-2,4,4);
      const abx = x + (ai.x / RIVER_WIDTH) * w; const aby = y + ((ai.y - top)/(bot-top))*h; ctx.fillStyle='#f7d8a7'; ctx.fillRect(abx-2,aby-2,4,4);
      ctx.restore();
    }

    function nearestDockTo(x,y){ let best=null, bd=1e9; for(let i=0;i<ports.length;i++){ const p=ports[i]; const d=dist(x,y,p.dockX,p.dockY); if(d<bd){ bd=d; best={x:p.dockX,y:p.dockY,index:i}; } } return best; }

    // ===== CAMERA & RENDER LOOP
    let last = performance.now();
    function frame(now){
      const dt = Math.min(0.05, (now - last)/1000); last = now;
      advanceClock(dt);
      updateVortices(dt);
      updateRibbons(dt);
      updateParticles(dt);
      updateBoat(dt);
      updateAI(dt);
      updateCamera(dt);

      // advance job timer only while underway
      if(job.state==='IN_TRANSIT'){ job.timer += dt; }

      // draw
      ctx.clearRect(0,0, canvas.clientWidth, canvas.clientHeight);
      drawRiverBackground();
      drawBars();
      if(SHOW.grid) drawGrid();
      if(SHOW.ribbons) drawRibbons();
      if(SHOW.vectors) drawFlowVectors();
      if(SHOW.vorts) { ctx.save(); ctx.lineWidth=1.5; for(const v of vortices){ const s=toScreen(v.x,v.y); ctx.beginPath(); ctx.arc(s.x,s.y,v.r,0,Math.PI*2); ctx.strokeStyle='rgba(255,255,255,0.08)'; ctx.stroke(); } ctx.restore(); }
      drawPorts();
      drawBoat(ai, false);
      drawBoat(boat, true);
      drawParticles();
      drawJobHUD();
      drawMinimap();

      // time-of-day tint
      drawTimeTint();

      // help overlay
      if(SHOW.help){
        ctx.save(); ctx.globalAlpha = 0.85; ctx.fillStyle = 'rgba(0,0,0,0.45)'; ctx.fillRect(canvas.clientWidth-380, canvas.clientHeight-192, 370, 180); ctx.globalAlpha = 1; ctx.fillStyle = '#dbe8f1'; ctx.font = '12px system-ui, sans-serif';
        const lines = [
          'W/S: throttle  |  A/D: steer  |  Space: stop  |  E: dock/undock (auto-moor)',
          'F: flow  R: ribbons  G: grid  V: vortices  B: sandbars  H: toggle help',
          'Dock in range when the prompt shows. While docked: L=Load, U=Unload, E=Depart.',
          'Tip: read the strands — ride slicks; avoid hatched shoals; fuel burns with throttle.',
          'New: camera lead (see ahead), ribbons hold when going upstream, load/unload hotkeys.'
        ];
        for(let i=0;i<lines.length;i++) ctx.fillText(lines[i], canvas.clientWidth-366, canvas.clientHeight-172 + i*20);
        ctx.restore();
      }

      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);

    function drawTimeTint(){
      const minutes = simClock.minutes; // 0..1440
      const dayFrac = (minutes % 1440) / 1440; // 0..1
      // Night 0-0.2, Dawn 0.2-0.27, Day 0.27-0.75, Dusk 0.75-0.82, Night 0.82-1
      let alpha = 0; let warm = 0;
      if(dayFrac<0.2 || dayFrac>0.82){ alpha = 0.35; } // night dim
      else if(dayFrac<0.27){ alpha = 0.18; warm = 0.25; } // dawn
      else if(dayFrac>0.75){ alpha = 0.18; warm = 0.2; } // dusk
      ctx.save();
      if(warm>0){ const grd = ctx.createLinearGradient(0,0,0,canvas.clientHeight); grd.addColorStop(0, `rgba(255,196,128,${0.18*warm})`); grd.addColorStop(1, 'rgba(0,0,0,0)'); ctx.fillStyle = grd; ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight); }
      if(alpha>0){ ctx.fillStyle = `rgba(0,0,0,${alpha})`; ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight); }
      ctx.restore();
    }

    // ===== Port UI / Economy =====
    const portUI = document.getElementById('portui');
    const portNameEl = document.getElementById('portname');
    const dockHullEl = document.getElementById('dock_hull');
    const dockFuelEl = document.getElementById('dock_fuel');
    const repairBtn = document.getElementById('btn_repair');
    const refuelBtn = document.getElementById('btn_refuel');
    const loadBtn = document.getElementById('btn_load');
    const unloadBtn = document.getElementById('btn_unload');
    const departBtn = document.getElementById('btn_depart');
    const jobsList = document.getElementById('jobs_list');
    const repairCostEl = document.getElementById('repair_cost');
    const refuelCostEl = document.getElementById('refuel_cost');

    function openPortUI(){
      if(boat.dockedAt===null) return;
      const p = ports[boat.dockedAt];
      portNameEl.textContent = p.name;
      dockHullEl.textContent = Math.round(boat.hull*100)+'%';
      dockFuelEl.textContent = Math.round(boat.fuel/boat.maxFuel*100)+'%';
      const repairCost = Math.round((1-boat.hull) * REPAIR_PRICE);
      const refuelCost = Math.round((boat.maxFuel-boat.fuel) * FUEL_PRICE);
      repairCostEl.textContent = repairCost; refuelCostEl.textContent = refuelCost;

      const cargoSec = document.getElementById('cargo_section');
      cargoSec.style.display = 'block';
      loadBtn.style.display = (job.state==='PICKUP' && job.origin===boat.dockedAt) ? 'inline-block' : 'none';
      unloadBtn.style.display = (job.state==='IN_TRANSIT' && job.dest===boat.dockedAt) ? 'inline-block' : 'none';

      jobsList.innerHTML = '';
      if(job.state==='NONE' || job.state==='DELIVERED' || job.state==='LATE'){
        const offers = jobsForPort(boat.dockedAt);
        offers.forEach((o)=>{
          const d = ports[o.dest];
          const row = document.createElement('div'); row.style.marginBottom = '8px';
          row.innerHTML = `${p.name} → <b>${d.name}</b> · Pay $${o.payout} · Time ${o.timeLimit}s `;
          const btn = document.createElement('button'); btn.className='btn'; btn.textContent='Accept';
          btn.onclick = ()=>{
            job.origin=o.origin; job.dest=o.dest; job.timeLimit=o.timeLimit; job.timer=0; job.payout=o.payout; job.state='PICKUP';
            updateJobUI();
            if(boat.dockedAt===job.origin){ performLoad(); } else { flashStatus('Contract accepted. Load at origin.'); }
            closePortUI();
          };
          row.appendChild(btn); jobsList.appendChild(row);
        });
      } else {
        const row = document.createElement('div'); row.style.opacity = 0.8; row.textContent = 'Active contract in progress.'; jobsList.appendChild(row);
      }

      portUI.style.display='block';
    }
    function closePortUI(){ portUI.style.display='none'; }

    // Buttons
    repairBtn.onclick = ()=>{ const cost = Math.round((1-boat.hull)*REPAIR_PRICE); if(cost<=boat.cash){ boat.cash-=cost; boat.hull=1; flashStatus('Hull repaired.'); openPortUI(); } else flashStatus('Not enough cash for repairs.'); };
    refuelBtn.onclick = ()=>{ const cost = Math.round((boat.maxFuel-boat.fuel)*FUEL_PRICE); if(cost<=boat.cash){ boat.cash-=cost; boat.fuel=boat.maxFuel; flashStatus('Tanks topped up.'); openPortUI(); } else flashStatus('Not enough cash to refuel.'); };

    loadBtn.onclick = ()=>{ performLoad(); };
    unloadBtn.onclick = ()=>{ performUnload(); };
    departBtn.onclick = ()=>{ if(boat.dockedAt!==null) undock(); };

    // Status toast helper
    const statusEl = document.getElementById('status');
    function flashStatus(msg){ statusEl.textContent = msg; statusEl.style.display='block'; statusEl.setAttribute('data-t','2.4'); }

    function updateJobUI(){ drawJobHUD(); }

    function tryLoad(){ if(boat.dockedAt!==null && job.state==='PICKUP' && job.origin===boat.dockedAt) performLoad(); }
    function tryUnload(){ if(boat.dockedAt!==null && job.state==='IN_TRANSIT' && job.dest===boat.dockedAt) performUnload(); }

    function performLoad(){
      if(job.state==='PICKUP' && job.origin===boat.dockedAt){ job.state='IN_TRANSIT'; job.timer=0; flashStatus('Cargo loaded. Make way!'); noticeEl.textContent='Loaded — Press E to depart, mind the current.'; closePortUI(); updateJobUI(); }
    }
    function performUnload(){
      if(job.state==='IN_TRANSIT' && job.dest===boat.dockedAt){ const onTime = job.timer <= job.timeLimit; const pay = onTime? job.payout : Math.floor(job.payout*0.45); boat.cash += pay; job.state = onTime? 'DELIVERED' : 'LATE'; flashStatus(onTime? `Delivered on time. +$${pay}` : `Delivered late. +$${pay}`); noticeEl.textContent='Cargo discharged — Harbormaster can refuel/repair. E to depart.'; updateJobUI(); openPortUI(); }
    }

    // ====== Developer Diagnostics (basic tests) ======
    function runDiagnostics(){
      const diag = document.getElementById('diag');
      let passed = 0, failed = 0; const logs=[];
      function assert(name, cond){ if(cond){ passed++; logs.push(`✔ ${name}`);} else { failed++; logs.push(`✘ ${name}`);} }

      // Test 1: Ribbons update should keep running and recycle above/below
      try {
        const beforeCounts = RIBBONS.reduce((a,r)=>a+r.pts.length,0);
        camera.y -= 1200; updateRibbons(0.016);
        camera.y += 2400; updateRibbons(0.016);
        camera.y -= 1200; // restore
        const afterCounts = RIBBONS.reduce((a,r)=>a+r.pts.length,0);
        assert('Ribbons stable & recyclable', beforeCounts === afterCounts);
      } catch(e){ assert('Ribbons update did not throw', false); console.error(e); }

      // Test 2: Camera lead moves toward ahead when moving downstream
      try {
        const wv = waterVelocity(boat.x, boat.y);
        boat.vy = wv.y + 50; const cy0 = camera.y; updateCamera(0.1); const cy1 = camera.y;
        assert('Camera leads downstream (y increases)', cy1 > cy0);
        boat.vy = wv.y - 50; const cy2 = camera.y; updateCamera(0.1); const cy3 = camera.y;
        assert('Camera leads upstream (y decreases)', cy3 < cy2);
      } catch(e){ assert('Camera lead test did not throw', false); console.error(e); }

      // Test 3: Load/Unload state transitions
      try {
        boat.dockedAt = 0; job.state='PICKUP'; job.origin=0; job.dest=1; performLoad();
        assert('Loading sets IN_TRANSIT', job.state==='IN_TRANSIT');
        job.timeLimit = 10; job.timer = 5; boat.dockedAt = 1; performUnload();
        assert('Unload sets DELIVERED/LATE', job.state==='DELIVERED' || job.state==='LATE');
      } catch(e){ assert('Load/Unload test did not throw', false); console.error(e); }

      // Test 4: Particle radius math never negative or NaN
      try {
        const lives = [1, 0.75, 0.5, 0.25, 0, -0.25];
        const ok = lives.every(L=> {
          const wrx = 10*(1-L), wry = 4*(1-L);
          const srx = 12*(1-L), sry = 8*(1-L);
          return [wrx,wry,srx,sry].every(v=> Number.isFinite(v) && v>=0);
        });
        assert('Particle radii non-negative across typical life range', ok);
      } catch(e){ assert('Particle radius test did not throw', false); console.error(e); }

      // Test 5: Bars radii always positive
      try {
        const ok = BARS.every(b=> b.rx>0 && b.ry>0);
        assert('Sandbar radii positive', ok);
      } catch(e){ assert('Sandbar radii test did not throw', false); console.error(e); }

      // Test 6: safeEllipsePath rejects invalid radii
      try {
        const rejected = (safeEllipsePath(0,0,-1,10)===false) && (safeEllipsePath(0,0,10,0)===false);
        assert('safeEllipsePath rejects negative/zero', rejected);
      } catch(e){ assert('safeEllipsePath test did not throw', false); console.error(e); }

      diag.style.display='block';
      diag.textContent = `Diagnostics: ${passed} passed / ${failed} failed`;
      console.groupCollapsed('Diagnostics'); logs.forEach(l=>console.log(l)); console.groupEnd();
    }
    // kick after first frame settles
    setTimeout(runDiagnostics, 400);

  })();
  </script>

  <!-- fade the status toast -->
  <script>
  (function(){ const statusEl = document.getElementById('status'); let last = performance.now(); function loop(now){ const dt = Math.min(0.05,(now-last)/1000); last = now; if(statusEl && statusEl.style.display==='block'){ const current = parseFloat(statusEl.getAttribute('data-t')||'0'); const next = current - dt; statusEl.setAttribute('data-t', String(next)); if(next<=0){ statusEl.style.display='none'; statusEl.removeAttribute('data-t'); } } requestAnimationFrame(loop);} requestAnimationFrame(loop); })();
  </script>
</body>
</html>
